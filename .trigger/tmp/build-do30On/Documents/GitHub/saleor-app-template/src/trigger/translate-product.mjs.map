{
  "version": 3,
  "sources": ["../../../../../../../../src/trigger/translate-product.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk\";\r\n\r\n// --- CONFIGURATION ---\r\nconst TARGET_LANGUAGES = [\r\n    { code: \"NL\", name: \"Dutch\" },\r\n    { code: \"DE\", name: \"German\" },\r\n    { code: \"FR\", name: \"French\" },\r\n    { code: \"IT\", name: \"Italian\" },\r\n    { code: \"ES\", name: \"Spanish\" },\r\n    { code: \"PT\", name: \"Portuguese\" },\r\n    { code: \"FI\", name: \"Finnish\" },\r\n    { code: \"ET\", name: \"Estonian\" },\r\n    { code: \"LV\", name: \"Latvian\" },\r\n    { code: \"LT\", name: \"Lithuanian\" },\r\n    { code: \"SK\", name: \"Slovak\" },\r\n    { code: \"SL\", name: \"Slovenian\" },\r\n    { code: \"EL\", name: \"Greek\" },\r\n    { code: \"HR\", name: \"Croatian\" },\r\n    { code: \"MT\", name: \"Maltese\" },\r\n];\r\n\r\nexport const translateProduct = task({\r\n    id: \"translate-product\",\r\n    run: async (payload: { productId: string }) => {\r\n        const apiUrl = process.env.SALEOR_API_URL;\r\n        const geminiKey = process.env.GOOGLE_API_KEY;\r\n        let saleorToken = (process.env.SALEOR_APP_TOKEN || process.env.SALEOR_TOKEN || \"\").trim();\r\n\r\n        if (!apiUrl || !saleorToken || !geminiKey) {\r\n            throw new Error(\"Missing SALEOR_API_URL, SALEOR_TOKEN, or GOOGLE_API_KEY\");\r\n        }\r\n\r\n        saleorToken = `Bearer ${saleorToken.replace(/^bearer\\s+/i, \"\")}`;\r\n\r\n        const saleorFetch = async (query: string, variables: any = {}) => {\r\n            const res = await fetch(apiUrl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Authorization': saleorToken,\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({ query, variables })\r\n            });\r\n            return await res.json();\r\n        };\r\n\r\n        // 1. Fetch Product Data\r\n        const productRes = await saleorFetch(`\r\n            query GetProduct($id: ID!) {\r\n                product(id: $id) {\r\n                    id\r\n                    name\r\n                    description\r\n                    translations {\r\n                        language {\r\n                            code\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        `, { id: payload.productId });\r\n\r\n        const product = productRes.data?.product;\r\n        if (!product) {\r\n            console.error(\"‚ùå Product lookup failed. Query:\", JSON.stringify({ query: \"GetProduct\", variables: { id: payload.productId } }));\r\n            console.error(\"‚ùå Response:\", JSON.stringify(productRes));\r\n            throw new Error(`Product not found for ID: ${payload.productId}`);\r\n        }\r\n\r\n        console.log(`üåç Translating Product: ${product.name} (${product.id})`);\r\n\r\n        const existingTranslations = new Set(product.translations.map((t: any) => t.language.code.toUpperCase()));\r\n\r\n        // 2. Translate to each language\r\n        for (const lang of TARGET_LANGUAGES) {\r\n            if (existingTranslations.has(lang.code)) {\r\n                console.log(`‚è© Skipping ${lang.name} (already translated)`);\r\n                continue;\r\n            }\r\n\r\n            console.log(`‚úçÔ∏è Translating to ${lang.name}...`);\r\n\r\n            const translatedName = await translateText(product.name, lang.name, geminiKey);\r\n            const translatedDescription = await translateText(product.description || \"\", lang.name, geminiKey, true);\r\n\r\n            // 3. Update Saleor Translation\r\n            const updateRes = await saleorFetch(`\r\n                mutation UpdateTranslation($id: ID!, $language: LanguageCodeEnum!, $input: TranslationInput!) {\r\n                    productTranslate(id: $id, languageCode: $language, input: $input) {\r\n                        errors { field message }\r\n                    }\r\n                }\r\n            `, {\r\n                id: product.id,\r\n                language: lang.code,\r\n                input: {\r\n                    name: translatedName,\r\n                    description: translatedDescription\r\n                }\r\n            });\r\n\r\n            if (updateRes.data?.productTranslate?.errors?.length > 0) {\r\n                console.error(`‚ùå Failed to update ${lang.name} translation:`, updateRes.data.productTranslate.errors);\r\n            } else {\r\n                console.log(`‚úÖ ${lang.name} translation updated.`);\r\n            }\r\n        }\r\n\r\n        console.log(`‚úÖ All translations processed for ${product.name}`);\r\n    }\r\n});\r\n\r\nasync function translateText(text: string, targetLanguage: string, apiKey: string, isJson: boolean = false): Promise<string> {\r\n    if (!text || text === \"{}\" || text === '{\"time\":0,\"blocks\":[],\"version\":\"2.25.0\"}') return text;\r\n\r\n    const prompt = isJson \r\n        ? `You are a professional e-commerce translator. Translate the following EditorJS JSON content into ${targetLanguage}. Keep the JSON structure identical, only translate the text values inside the blocks. Do not translate HTML tags or technical keys. Return ONLY the translated JSON.\\n\\nContent: ${text}`\r\n        : `Translate the following product name into ${targetLanguage}. Return ONLY the translated string.\\n\\nContent: ${text}`;\r\n\r\n    try {\r\n        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                contents: [{ parts: [{ text: prompt }] }]\r\n            })\r\n        });\r\n\r\n        const data = await response.json();\r\n        const translatedContent = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();\r\n\r\n        if (!translatedContent) {\r\n            console.warn(`‚ö†Ô∏è Gemini returned empty translation for ${targetLanguage}`);\r\n            return text;\r\n        }\r\n\r\n        // Clean up markdown code blocks if Gemini wrapped them\r\n        return translatedContent.replace(/^```json\\n?/, '').replace(/\\n?```$/, '');\r\n    } catch (e) {\r\n        console.error(`‚ùå Translation error for ${targetLanguage}:`, e);\r\n        return text;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
